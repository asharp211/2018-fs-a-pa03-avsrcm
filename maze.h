/* These are your declarations.
 * Do not edit this file at all.
 * If you change it and your program does not run as a result, you will receive a grade of %0.
 */

#include <iostream>

#ifndef MAZE
#define MAZE

using std::cout;
using std::endl;
using std::cin;
using std::cerr;
using std::string;


/*
Writes to a string array containing:
    * the your (the student authorâ€™s) Campus Username (at index 0)
    * and Student ID# (at index 1).
Takes as input a pre-existing length-2 string array.
*/
void get_identity(string my_id[]);


/**
Use this to help you enumerate the directions.
Gets passed into one function below.
**/
enum direction
{
    NORTH,
    SOUTH,
    EAST,
    WEST
};


/**
Creates a dynamically allocated array of std::string elements.
Returns a pointer to that array.
**/
string * build_matrix(int rows);


/**
Fills the matrix with one line per string in the array.
Use the std::string getline method.
Why don't you need to send in cols?
**/
void fill_matrix(string *matrix, int rows);


/**
Print the matrix as in the sample_output.txt
**/
void print_matrix(string *matrix, int rows);


/**
Delete the dynamically allocated array of strings.
Why don't you need to send in rows or cols?
Don't leave a dangling pointer (handle this in the function).
**/
void delete_matrix(string *&matrix);


/**
Finds the starting position of Niobe.
Note: row and col are passed by reference; what does this do for you?
**/
void find_start(string *matrix, int rows, int &row, int &col);


/**
This is the recursive backtracking function you need to write.
It should return true if you found the solution,
and false if there is no solution.
It should leave a trail of @ signs along the path to the solution.
Make sure to build your solution with strong emphasis on the pseudocode;
do not try to code it first, first work out the solution on paper/markerboard.
**/
bool find_exit(string *matrix, int row, int col);


/**
Returns true if row and col are the final exit location,
and false otherwise.
**/
bool at_end(string *matrix, int row, int col);


/**
Returns true if the position indexed by row and col when incremented in direction is a valid move,and false otherwise.
What is a valid move?
This function checks whether the row and coly, after being incremented in 'direction', produce a valid move, not the validity of the position indexed by row and col alone.
North is up, South is down, East is right, and West is left.
**/
bool valid_move(string *matrix, int row, int col, direction d);

#endif

